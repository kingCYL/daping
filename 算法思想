八大算法：枚举、递推、递归、分治、贪心、试探法、动态迭代（规划）、模拟
https://www.cnblogs.com/feng9exe/p/10371489.html
https://zhuanlan.zhihu.com/p/428479862
https://cloud.tencent.com/developer/article/1755432

1. 枚举
   穷举，穷尽列举
   将问题的所有可能答案一一列举，根据判断条件判断此答案是否合适，一般用循环实现
   确定枚举对象、枚举范围和判定条件。
   逐一列举可能的解，验证每个解是否是问题的解。
   例：百钱买百鸡、填写运算符
   全买公鸡最多买20只，全买母鸡最多买33只，全买小鸡最多可以买300只(数量超过”百鸡“条件，所以从前两个入手)
    let res = null
    for (let i = 0; i <= 20; i++) { //枚举范围
      for (let j = 0; j <= 33; j++) { //枚举范围
        let num = 100 - i - j
        if (i * 5 + j * 3 + num/3 === 100) { //判定条件
          res = `${i}--${j}--${num}`
          console.log(res)
        }
      }
    }

2.递推
  从已知条件出发，逐步推算出问题的解
  1.顺推法：从已知条件出发，逐步推算出要解决问题的方法。
  2.逆推法：从已知结果出发，用迭代表达式逐步推算出问题开始的条件，即顺推法的逆过程。
  经典运用：斐波那契数列（顺推法）第N项、银行存款（逆推法）、兔子繁殖、leetcode70题：爬楼梯
  斐波那契数列：递推
  function fn(n) {
    let current = 0;
    let next = 1;
    let temp;//中介
    for(let i = 0; i < n; i++) {
        temp = current;
        current = next;
        next += temp;
        // [current, next] = [next, current + next] ES6解构写法
    }
    return current;
}
  斐波那契数列优化：尾递归
  （ function fn(n, current = 0, next = 1) {
    if(n == 0) return current;//0
    if(n == 1) return next;//1
    return fn(n - 1, next, current + next);//尾调用
}
  斐波那契数列优化:存储变量减少循环次数，类似闭包
  function fib(n){
    function fib_(n,a,b){
      if(n== 0) return a
      return fib_(n-1,b,a+b)//每次b赋值给a,避免重复计算
    }
    return fib_(n,0,1)
  }

3.递归
  1.递归过程一般通过函数或子过程实现；
  2.递归算法在函数或子过程的内部，直接或间接调用自己的算法
  3.递归算法实际上是把问题转化为规模缩小了的同类问题的子问题，然后再递归调用函数或过程来表示问题的解

  注意：必须有一个明确的递归结束条件；如果递归次数过多，容易造成栈溢出。
  递归算法对常用的算法如普通循环等，运行效率较低；并且在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储，递归太深，容易发生栈溢出

  经典运用：汉诺塔问题、阶乘问题、树的遍历及相关操作
  记住用函数尾调用优化
  阶乘问题：
  function tailFactiral(n,total){
    if(n===1) return total
    return tailFactiral(n-1,n*total)
  }
  function factorial(n){
    return tailFactiral(n,1)
  }

4.分治
  将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。只要求出子问题的解，就可得到原问题的解。

  一般步骤：

  1.分解，将要解决的问题划分成若干个规模较小的同类问题

  2.求解，当子问题划分得足够小时，用较简单的方法解决

  3.合并，按原问题的要求，将子问题的解逐层合并构成原问题的解

  一句话总结：从上而下，再从下而上。先分解，再求解，再合并
  自顶向下，将主要问题划分逐层级划分为子问题
  自底向上，将子问题的解逐层递增融入主问题的求解中

  经典运用：大数相乘问题、比赛日程安排、二分查找（仅适用于有序数组）、归并排序、快排、汉诺塔问题、React 时间分片

5. 贪心
  从问题的某一个初始解出发，逐步逼近给定的目标，以便尽快求出更好的解。
  总是做出当前的最优选择，即期望通过局部的最优选择获得整体的最优选择

  局限：

  不能保证最后的解是最优的；

  不能求最大最小解问题；

  只能求满足某些约束条件的可行解范围。

  基本过程：

  1.从问题的某一初始解出发（明确什么是最优解（期望））

  2.每一个while都能向总目标前进一步（问题分成多个步骤，每一步都需要满足问题的约束条件）

  3.求出可行解的一个解元素（每一步都做出一个局部最优的选择）

  4.不可取消：选择一旦做出，在后面遇到任何情况都不可取消

  5.由所有解元素组合（叠加）成问题的一个可行解

  当满足一下条件时，可以使用：
    原问题复杂度过高
    求全局最优解的数学模型难以建立或计算量过大
    没有太大必要一定要求出全局最优解，“比较优”就可以

  经典运用：装箱问题、找零方案、活动选择问题、最小生成树算法、单源最短路径的 Dijkstra 算法、Huffman 压缩编码、背包问题、活动选择问题等
          旅行推销员问题。 给定一系列城市和每对城市之间的距离，求解访问每一座城市一次并回到起始城市的最短回路。

6.回溯（试探法/探索法）
  在试探算法中，放弃当前候选解，并继续寻找下一个候选解的过程称为回溯。扩大当前候选解的规模，以继续试探的过程称为向前试探。
  它会在每一步做出选择，一旦发现这个选择无法得到期望结果（不正确/不满足条件），就回溯回去（退到做出选择的那一步），重新做出选择，直到得到解或证明无解才终止
  典型：深度优先搜索（dfs）

  基本步骤：

  1.针对所给问题，定义问题的解空间

  2.确定易于搜索的解空间结构

  3.以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索

  经典运用：深度优先搜索（dfs）、八皇后问题、29选7彩票组合、数独、全排列、正则表达式匹配、0-1背包问题

7.动态规划（迭代算法/辗转法）
　是一种不断用变量的旧值递推新值的过程，解决问题时总是重复利用一种方法。
　　1.确定迭代变量：直接或间接地不断由旧值递推出新值的变量
　　2.建立迭代关系式：新值与旧值的公式或关系。（解决迭代问题的关系）
　　3.对迭代过程进行控制：确定迭代过程什么时候结束
　　　　所需的迭代次数是个确定值，可以计算出来：可以构建一个固定次数的循环来实现对迭代过程的控制；
　　　　所需的迭代次数无法确定：需要进一步分析出用来结束迭代过程的条件。


将问题划分为多个子问题，但是子问题之间不是互相独立的
最优化原理、无后效性

　　经典运用：求平方根问题、背包问题

8.模拟
  对真实事物或者过程的虚拟。
　经典运用：猜数字游戏、掷骰子问题
